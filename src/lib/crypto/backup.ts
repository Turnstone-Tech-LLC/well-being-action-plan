/**
 * Backup encryption/decryption module using Web Crypto API.
 * Uses AES-GCM for encryption with PBKDF2 key derivation from passphrase.
 */

import type { LocalActionPlan } from '$lib/db/index';

/**
 * Current backup format version.
 * Increment when making breaking changes to the backup format.
 */
export const BACKUP_FORMAT_VERSION = 1;

/**
 * File extension for backup files.
 */
export const BACKUP_FILE_EXTENSION = '.wbap';

/**
 * MIME type for backup files.
 */
export const BACKUP_MIME_TYPE = 'application/octet-stream';

/**
 * Structure of an encrypted backup file.
 */
export interface EncryptedBackup {
	/** Backup format version for future compatibility */
	version: number;
	/** Base64-encoded salt used for key derivation */
	salt: string;
	/** Base64-encoded initialization vector for AES-GCM */
	iv: string;
	/** Base64-encoded encrypted data */
	data: string;
}

/**
 * Structure of the decrypted backup payload.
 */
export interface BackupPayload {
	/** Backup format version */
	version: number;
	/** Timestamp when backup was created */
	createdAt: string;
	/** The action plan data (without local-only fields like id) */
	plan: Omit<LocalActionPlan, 'id'>;
}

/**
 * PBKDF2 parameters for key derivation.
 */
const PBKDF2_ITERATIONS = 100000;
const PBKDF2_HASH = 'SHA-256';
const SALT_LENGTH = 16;
const IV_LENGTH = 12;
const KEY_LENGTH = 256;

/**
 * Derive a cryptographic key from a passphrase using PBKDF2.
 */
async function deriveKey(passphrase: string, salt: Uint8Array<ArrayBuffer>): Promise<CryptoKey> {
	const encoder = new TextEncoder();
	const passphraseKey = await crypto.subtle.importKey(
		'raw',
		encoder.encode(passphrase),
		'PBKDF2',
		false,
		['deriveKey']
	);

	return crypto.subtle.deriveKey(
		{
			name: 'PBKDF2',
			salt,
			iterations: PBKDF2_ITERATIONS,
			hash: PBKDF2_HASH
		},
		passphraseKey,
		{
			name: 'AES-GCM',
			length: KEY_LENGTH
		},
		false,
		['encrypt', 'decrypt']
	);
}

/**
 * Convert a Uint8Array to a base64 string.
 */
function arrayBufferToBase64(buffer: Uint8Array): string {
	let binary = '';
	for (let i = 0; i < buffer.length; i++) {
		binary += String.fromCharCode(buffer[i]);
	}
	return btoa(binary);
}

/**
 * Convert a base64 string to a Uint8Array.
 */
function base64ToArrayBuffer(base64: string): Uint8Array<ArrayBuffer> {
	const binary = atob(base64);
	const buffer = new Uint8Array(binary.length);
	for (let i = 0; i < binary.length; i++) {
		buffer[i] = binary.charCodeAt(i);
	}
	return buffer as Uint8Array<ArrayBuffer>;
}

/**
 * Encrypt a backup payload with a passphrase.
 *
 * @param payload - The backup data to encrypt
 * @param passphrase - User-provided passphrase for encryption
 * @returns Encrypted backup object ready to be saved as JSON
 */
export async function encryptBackup(
	payload: BackupPayload,
	passphrase: string
): Promise<EncryptedBackup> {
	const encoder = new TextEncoder();
	const salt = crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
	const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH));

	const key = await deriveKey(passphrase, salt);
	const plaintext = encoder.encode(JSON.stringify(payload));

	const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, plaintext);

	return {
		version: BACKUP_FORMAT_VERSION,
		salt: arrayBufferToBase64(salt),
		iv: arrayBufferToBase64(iv),
		data: arrayBufferToBase64(new Uint8Array(ciphertext))
	};
}

/**
 * Decrypt an encrypted backup with a passphrase.
 *
 * @param backup - The encrypted backup object
 * @param passphrase - User-provided passphrase for decryption
 * @returns Decrypted backup payload
 * @throws Error if decryption fails (wrong passphrase or corrupted data)
 */
export async function decryptBackup(
	backup: EncryptedBackup,
	passphrase: string
): Promise<BackupPayload> {
	const decoder = new TextDecoder();
	const salt = base64ToArrayBuffer(backup.salt);
	const iv = base64ToArrayBuffer(backup.iv);
	const ciphertext = base64ToArrayBuffer(backup.data);

	const key = await deriveKey(passphrase, salt);

	try {
		const plaintext = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ciphertext);
		const json = decoder.decode(plaintext);
		return JSON.parse(json) as BackupPayload;
	} catch {
		throw new Error('Decryption failed. Please check your passphrase and try again.');
	}
}

/**
 * Create a backup from a local action plan.
 *
 * @param plan - The local action plan to backup
 * @param passphrase - User-provided passphrase for encryption
 * @returns Encrypted backup as a JSON string
 */
export async function createBackup(plan: LocalActionPlan, passphrase: string): Promise<string> {
	// Remove local-only fields (id is auto-generated by IndexedDB)
	const planData: Omit<LocalActionPlan, 'id'> = {
		actionPlanId: plan.actionPlanId,
		revisionId: plan.revisionId,
		revisionVersion: plan.revisionVersion,
		accessCode: plan.accessCode,
		planPayload: plan.planPayload,
		deviceInstallId: plan.deviceInstallId,
		installedAt: plan.installedAt,
		lastAccessedAt: plan.lastAccessedAt
	};

	const payload: BackupPayload = {
		version: BACKUP_FORMAT_VERSION,
		createdAt: new Date().toISOString(),
		plan: planData
	};

	const encrypted = await encryptBackup(payload, passphrase);
	return JSON.stringify(encrypted, null, 2);
}

/**
 * Restore a backup from an encrypted backup string.
 *
 * @param backupJson - The encrypted backup JSON string
 * @param passphrase - User-provided passphrase for decryption
 * @returns The decrypted plan data ready to save to IndexedDB
 * @throws Error if parsing or decryption fails
 */
export async function restoreBackup(
	backupJson: string,
	passphrase: string
): Promise<Omit<LocalActionPlan, 'id'>> {
	let backup: EncryptedBackup;

	try {
		backup = JSON.parse(backupJson) as EncryptedBackup;
	} catch {
		throw new Error('Invalid backup file format. Please select a valid .wbap file.');
	}

	// Validate backup structure
	if (!backup.version || !backup.salt || !backup.iv || !backup.data) {
		throw new Error('Invalid backup file structure. Please select a valid .wbap file.');
	}

	// Check version compatibility
	if (backup.version > BACKUP_FORMAT_VERSION) {
		throw new Error(
			`This backup was created with a newer version of the app (v${backup.version}). Please update your app to restore this backup.`
		);
	}

	const payload = await decryptBackup(backup, passphrase);

	// Update timestamps for the restored plan
	return {
		...payload.plan,
		installedAt: new Date(),
		lastAccessedAt: new Date()
	};
}

/**
 * Generate a suggested filename for a backup.
 *
 * @param planNickname - Optional nickname from the plan for the filename
 * @returns Suggested filename with timestamp
 */
export function generateBackupFilename(planNickname?: string): string {
	const date = new Date().toISOString().split('T')[0];
	const safeName = planNickname
		? planNickname.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase()
		: 'wellbeing-plan';
	return `${safeName}-backup-${date}${BACKUP_FILE_EXTENSION}`;
}

/**
 * Validate that a file has the correct extension for a backup.
 *
 * @param filename - The filename to check
 * @returns True if the file has a valid backup extension
 */
export function isValidBackupFile(filename: string): boolean {
	const lowerName = filename.toLowerCase();
	return lowerName.endsWith(BACKUP_FILE_EXTENSION) || lowerName.endsWith('.json');
}
