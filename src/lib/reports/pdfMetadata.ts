/**
 * PDF metadata types and constants for check-in summary embedding.
 *
 * This module defines the structure for embedding structured data in PDFs
 * generated by the EHR PDF generator, enabling reliable extraction during
 * provider revision sessions.
 */

/**
 * Prefix used to identify WBAP metadata in PDF keywords field.
 */
export const METADATA_PREFIX = 'WBAP_METADATA:';

/**
 * Current metadata version for forward compatibility.
 */
export const CURRENT_METADATA_VERSION = 1;

/**
 * Type identifier for check-in summary metadata.
 */
export const METADATA_TYPE = 'wbap-checkin-summary' as const;

/**
 * Structured data embedded in EHR PDFs for extraction during revisions.
 */
export interface PdfCheckInMetadata {
	/** Metadata schema version */
	version: number;
	/** Type identifier for this metadata */
	type: typeof METADATA_TYPE;
	/** The actual check-in summary data */
	data: {
		/** Date range covered by the check-ins */
		dateRange: { start: string; end: string };
		/** Total number of check-ins in the period */
		totalCheckIns: number;
		/** Distribution of check-ins by zone (counts, not percentages) */
		zoneDistribution: { green: number; yellow: number; red: number };
		/** Most used coping skills with usage count */
		topCopingSkills: Array<{ id: string; title: string; count: number }>;
		/** Feeling notes from Yellow/Red zone check-ins (limited to 10) */
		feelingNotes: Array<{ zone: string; date: string; note: string }>;
		/** Supportive adults contacted with contact count */
		adultsContacted: Array<{ name: string; count: number }>;
		/** When the PDF was generated */
		generatedAt: string;
	};
}

/**
 * Encode metadata for embedding in PDF keywords field.
 * Uses base64 encoding to safely embed JSON in the keywords field.
 */
export function encodeMetadata(metadata: PdfCheckInMetadata): string {
	const json = JSON.stringify(metadata);
	// Use btoa for browser, or Buffer for Node.js
	if (typeof btoa === 'function') {
		return METADATA_PREFIX + btoa(json);
	}
	return METADATA_PREFIX + Buffer.from(json).toString('base64');
}

/**
 * Decode metadata from PDF keywords field.
 * Returns null if the string doesn't contain valid WBAP metadata.
 */
export function decodeMetadata(keywords: string): PdfCheckInMetadata | null {
	if (!keywords || !keywords.includes(METADATA_PREFIX)) {
		return null;
	}

	try {
		// Find the metadata portion (may have other keywords)
		const metadataStart = keywords.indexOf(METADATA_PREFIX);
		const base64Part = keywords
			.slice(metadataStart + METADATA_PREFIX.length)
			.split(/[,\s]/)[0] // Stop at comma or whitespace (other keywords)
			.trim();

		// Decode base64
		let json: string;
		if (typeof atob === 'function') {
			json = atob(base64Part);
		} else {
			json = Buffer.from(base64Part, 'base64').toString('utf-8');
		}

		const parsed = JSON.parse(json) as PdfCheckInMetadata;

		// Validate the structure
		if (parsed.type !== METADATA_TYPE) {
			return null;
		}

		return parsed;
	} catch {
		return null;
	}
}

/**
 * Validate that metadata has the expected structure and version.
 */
export function isValidMetadata(metadata: unknown): metadata is PdfCheckInMetadata {
	if (!metadata || typeof metadata !== 'object') {
		return false;
	}

	const m = metadata as PdfCheckInMetadata;

	return (
		typeof m.version === 'number' &&
		m.type === METADATA_TYPE &&
		m.data !== null &&
		typeof m.data === 'object' &&
		typeof m.data.totalCheckIns === 'number' &&
		typeof m.data.dateRange === 'object' &&
		typeof m.data.zoneDistribution === 'object'
	);
}
